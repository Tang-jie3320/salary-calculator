<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8">
<title>粒子爱心效果</title>
<style>
  html, body {
    margin: 0;
    padding: 0;
    background: #0b0b1b;
    overflow: hidden;
    font-family: sans-serif;
    color: #fff;
  }
  canvas { display: block; }
  #love-text {
    position: absolute;
    top: 60%;
    width: 100%;
    text-align: center;
    font-size: 20px;
    color: #fff;
  }
  #love-text span {
    color: #ff4b8b;
    font-size: 18px;
  }
</style>
</head>
<body>
<canvas id="canvas"></canvas>
<div id="love-text">
    小兮 <span>❤️</span>
</div>
<script src="heart-particle.js"></script>
<script>
    const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let w,h;
function resize(){
  w = canvas.width = window.innerWidth;
  h = canvas.height = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

// 爱心参数方程
function heart(t){
  return {
    x: 16*Math.pow(Math.sin(t),3),
    y: 13*Math.cos(t)-5*Math.cos(2*t)-2*Math.cos(3*t)-Math.cos(4*t)
  }
}

// 粒子数组
const particleCount = 2000;
const particles = [];

// 初始化粒子
for(let i=0;i<particleCount;i++){
  const t=Math.random()*Math.PI*2;
  const edge=heart(t);
  const k=Math.random()*0.8 + 0.2; // 控制粒子靠近中心或边缘
  const layer = Math.random()<0.25?'outer':'inner';
  particles.push({
    x: edge.x*k,
    y: edge.y*k,
    baseX: edge.x*k,
    baseY: edge.y*k,
    size: layer==='outer'?Math.random()*2+1.5:Math.random()*1.5+0.5,
    angle: Math.random()*Math.PI*2,
    speed: Math.random()*0.015+0.003,
    layer
  });
}

// 动画
function animate(){
  ctx.clearRect(0,0,w,h);

  const scale = Math.min(w,h)/40;
  const beat = 1 + Math.sin(Date.now()/400)*0.05;

  particles.forEach(p=>{
    p.angle += p.speed;
    const offsetX = Math.cos(p.angle)*0.3;
    const offsetY = Math.sin(p.angle)*0.3;

    const x = w/2 + (p.baseX+offsetX)*scale*beat;
    const y = h/2 - (p.baseY+offsetY)*scale*beat;

    ctx.beginPath();
    ctx.arc(x,y,p.size,0,Math.PI*2);

    if(p.layer==='outer'){
      ctx.fillStyle = 'rgba(255,255,255,'+(Math.random()*0.5+0.5)+')';
      ctx.shadowColor='rgba(255,255,255,0.7)';
      ctx.shadowBlur=4;
    } else {
      const hue = Math.floor((Math.atan2(p.baseY,p.baseX)*180/Math.PI+360)%360);
      const lum = 50 + Math.sin(Date.now()/1000+p.angle)*15;
      ctx.fillStyle = `hsl(${hue},80%,${lum}%)`;
      ctx.shadowBlur=0;
    }
    ctx.fill();
    ctx.shadowBlur=0;
  });

  requestAnimationFrame(animate);
}

animate();

</script>
</body>
</html>
